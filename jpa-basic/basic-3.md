## 준영속 상태 특징
- 거의 비영속 상태에 가까움<br/>
영속성 컨텍스트가 관리하지 않는 상태이기 때문에 1차 캐싱, 쓰기 지연, 지연 로딩, 변경 감지와 같은 기능들은<br/>
동작하지 않는다.
- 식별자 값을 가지고 있다<br/>
비영속 상태는 식별자 값이 없을 수도 있지만 준영속 상태는 이미 한 번 영속 상태였으니 반드시 식별자 값을<br/>
가지고 있다.
- 지연 로딩을 할 수 없다<br/>
영속성 컨텍스트가 관리하지 않으니 준영속 상태는 지연 로딩을 할 수 없는 것이다. 지연 로딩은 프록시 객체와<br/>
연관 되어 있다.

<br/>
<br/>

## 준영속 상태 엔티티의 Update 기능 주의점
준영속 상태인 엔티티를 Update 를 하려고 하는 방법은 2가지가 있다. 변경 감지와 병합 기능을 사용하는 것인데<br/>
이 둘은 비슷해 보이지만 차이점이 존재한다. (단, 트랜잭션 안에서 이 과정이 진행 되어야 한다)

- 변경 감지: 준영속 상태인 엔티티를 일단 Id 식별자를 통해 find() 조회한다. 준영속 상태인 엔티티이기 때문에<br/> 
1차 캐싱이 안되어 있으므로 DB에서 데이터 1건을 조회할 것이다. 이 조회한 데이터에서 변경하고 싶은 필드 값을<br/>
변경하고 commit 한다.

- 병합: 준영속 상태인 A엔티티를 merge() 를 통해 영속화 하는데, 준영속 상태였기 때문에 1차 캐시에는 당연히<br/>
엔티티 정보는 없을 것이고 DB에서 조회해서 정보를 가져올 것이다. 여기서 부터 '변경 감지'와 차이점이 발생<br/>
하는데 병합 방식은 merge할 대상인 A엔티티의 모든 필드 값 데이터들을 조회한 DB 데이터에 모두 채우고<br/>
변경된 새로운 엔티티를 만들어 반환한다. 결론은 merge에 대상이였던 A 엔티티는 영속화되는 것이 아니라 <br/>
A 엔티티가 가지고있던 모든 필드 값 데이터들만 채워넣은 새로운 영속상태의 엔티티가 반환되는 것이다.

<br/>

=> 이러한 내부 동작 방식이 다르고 실제 개발할 때 큰 차이점이 존재하는 것이다. 회원의 정보를 수정하는 일이<br/>
있고 클라이언트는 회원의 ID값과 수정된 회원명 2가지 데이터만 넘겨준다고 가정해보자.

1. 변경감지 <br/>
변경 감지는 먼저 find를 통해 Member 엔티티를 조회해 올 것이다. 해당 엔티티에 회원명 필드를 수정하고<br/>
커밋하면 영속성 컨텍스트의 변경 감지 기능으로 변경된 값만 체크하여 DB 데이터를 바꿔줄 것이다.

2. 병합 <br/>
병합은 비영속 or 준영속 상태인 Member 엔티티에 변경된 회원명 필드 값을 넣고, merge()를 사용하여 <br/>
새로운 엔티티의 값들을 채워넣어 커밋했다. Member 엔티티의 비밀번호, 연락처 등 이와같은 다른 필드가<br/> 
존재하면다면 해당 필드 값들은 NULL일 수도 있을 것이고 이 값들을 전부 Update를 수행하게 되는 것이다.<br/>
즉, 원래 회원명만 바꾸려고 merge를 사용한거지만 ID, Name 값을 제외한 비밀번호, 연락처, 이메일 등등 <br/>
모든 회원 컬럼들의 정보가 NULL로 바뀌게 된다. 심각한 버그를 발생시키는 상황이다. 

<br/>

따라서 수정기능을 개발할 때에는 정말 merge 기능을 완벽히 컨트롤하여 사용할 것이 아니라면, 변경 감지 기능을<br/>
사용할 것을 권장한다. 그러나 사람은 언제나 실수를 하기 마련이며 merge와 같은 방식은 버그를 만들어낼<br/>
여지가 있고 그냥 변경감지 기능을 사용하는 것이 더 안전한 방식이다. 결론, 변경감지 기능을 사용하자 